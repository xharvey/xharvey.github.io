---
layout: post
title: Python编程
---



# 数据库 #
【2.x】导入MySQLdb模块，先对数据库进行连接，cursor.execute(sql)执行sql语句，增删改后db.commit()提交改动
	
	import MySQLdb
	db = MySQLdb.connect("localhost", "testuser", "test123", "TESTDB", charset='utf8' ) # 打开数据库连接
	cursor = db.cursor()
	# 如果数据表已经存在使用 execute() 方法删除表。
	cursor.execute("DROP TABLE IF EXISTS EMPLOYEE")

	# SQL创建语句
	sql = """CREATE TABLE EMPLOYEE (
         FIRST_NAME  CHAR(20) NOT NULL,
         LAST_NAME  CHAR(20),
         AGE INT,  
         SEX CHAR(1),
         INCOME FLOAT )"""
	cursor.execute(sql)
	db.close()
	
	# SQL 插入语句
	sql = """INSERT INTO EMPLOYEE(FIRST_NAME,
         LAST_NAME, AGE, SEX, INCOME)
         VALUES ('Mac', 'Mohan', 20, 'M', 2000)"""

	# SQL 查询语句
	sql = "SELECT * FROM EMPLOYEE \
       WHERE INCOME > '%d'" % (1000)

	# SQL 更新语句
	sql = "UPDATE EMPLOYEE SET AGE = AGE + 1 WHERE SEX = '%c'" % ('M')
【3.x】
	python3中MySQLdb不可使用，可以使用pymysql


# 网络编程 #
##### http

简单请求get、post、http header 

```
from urllib import request
```
```
import requests

```

##### Tcp

服务端
	
	#!/usr/bin/python
	# -*- coding: UTF-8 -*-
	# 文件名：server.py
	
	import socket               # 导入 socket 模块
	
	s = socket.socket()         # 创建 socket 对象
	host = socket.gethostname() # 获取本地主机名
	port = 12345                # 设置端口
	s.bind((host, port))        # 绑定端口
	
	s.listen(5)                 # 等待客户端连接，最大连接数
	while True:
	    c, addr = s.accept()     # 建立客户端连接。
	    print '连接地址：', addr
	    c.send('欢迎访server！')  #发送数据
	    c.close()                # 关闭连接

客户端
	
	#!/usr/bin/python
	# -*- coding: UTF-8 -*-
	# 文件名：client.py
	
	import socket               # 导入 socket 模块
	
	s = socket.socket()         # 创建 socket 对象
	host = socket.gethostname() # 获取本地主机名
	port = 12345                # 设置端口号
	
	s.connect((host, port))
	print s.recv(1024)          #接收返回字符串数据最大字节
	s.close() 

# SMTP
SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源
地址到目的地址传送邮件的规则，由它来控制信件的中转方式。
python的smtplib提供了一种很方便的途径发送电子邮件。它对smtp协议进行了简单的封装。

```
#创建smtp对象
import smtplib
smtpObj = smtplib.SMTP( [host [, port [, local_hostname]]] )
#发送邮件接口
SMTP.sendmail(from_addr, to_addrs, msg[, mail_options, rcpt_options])
```
实例(普通文本邮件)

```
#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
import smtplib
from email.mime.text import MIMEText
from email.header import Header
 
sender = 'from@runoob.com'
receivers = ['123@test.com']  # 接收邮件，可设置为你的QQ邮箱或者其他邮箱
 
# 三个参数：第一个为文本内容，第二个 plain 设置文本格式，第三个 utf-8 设置编码
message = MIMEText('Python 邮件发送测试...', 'plain', 'utf-8')
message['From'] = Header("A", 'utf-8')   # 发送者
message['To'] =  Header("B", 'utf-8')        # 接收者
 
subject = 'Python SMTP 邮件测试'
message['Subject'] = Header(subject, 'utf-8')
 
try:
    smtpObj = smtplib.SMTP('localhost')
    smtpObj.sendmail(sender, receivers, message.as_string())
    print "邮件发送成功"
except smtplib.SMTPException:
    print "Error: 无法发送邮件"
```


# 多线程 #
##### thread模块创建线程
    
	thread.start_new_thread ( function, args[, kwargs] )

##### 线程同步
使用Thread对象的Lock和Rlock可以实现简单的线程同步，这两个对象都有acquire方法和release方法，对于那些需要每次只允许一个线程操作的数据，可以将其操作放到acquire和release方法之间

##### 线程优先级队列（ Queue）
Python的Queue模块中提供了同步的、线程安全的队列类，包括FIFO（先入先出)队列Queue，LIFO（后入先出）队列LifoQueue，和优先级队列PriorityQueue。这些队列都实现了锁原语，能够在多线程中直接使用。可以使用队列来实现线程间的同步

```
#!/usr/bin/python
# -*- coding: UTF-8 -*-
 
import Queue
import threading
import time
 
exitFlag = 0
 
class myThread (threading.Thread):
    def __init__(self, threadID, name, q):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.q = q
    def run(self):
        print "Starting " + self.name
        process_data(self.name, self.q)
        print "Exiting " + self.name
 
def process_data(threadName, q):
    while not exitFlag:
        queueLock.acquire()
        if not workQueue.empty():
            data = q.get()
            queueLock.release()
            print "%s processing %s" % (threadName, data)
        else:
            queueLock.release()
        time.sleep(1)
 
threadList = ["Thread-1", "Thread-2", "Thread-3"]
nameList = ["One", "Two", "Three", "Four", "Five"]
queueLock = threading.Lock()
workQueue = Queue.Queue(10)
threads = []
threadID = 1
 
# 创建新线程
for tName in threadList:
    thread = myThread(threadID, tName, workQueue)
    thread.start()
    threads.append(thread)
    threadID += 1
 
# 填充队列
queueLock.acquire()
for word in nameList:
    workQueue.put(word)
queueLock.release()
 
# 等待队列清空
while not workQueue.empty():
    pass
 
# 通知线程是时候退出
exitFlag = 1
 
# 等待所有线程完成
for t in threads:
    t.join()
print "Exiting Main Thread"
```


# 爬虫 #
爬取网络图片：获取源码，匹配正则，下载
	
	# coding:utf-8
	import urllib
	import re
	
	def get_html(url):
	    page = urllib.urlopen(url)		#获取网页源码
	    html = page.read()
	    return html
	
	reg = r'src="(.+?\.jpg)" width'
	reg_img = re.compile(reg)
	imglist = reg_img.findall(get_html('http://tieba.baidu.com/p/1753935195'))	#匹配图片正则
	x = 0
	for img in imglist:
	    urllib.urlretrieve(img, '%s.jpg' %x)	下载图片
	    x += 1



